#!/bin/bash

# Exit immediately if a command exits with a non-zero status.
set -euo pipefail

# --- Configuration ---
CONFIG_FILE="config.yaml"
TFVARS_FILE_DEPLOY="argocd.tfvars"
TF_MODULE_PATH_DEPLOY="deploy-argocd" # Subfolder for Argo CD Helm chart deployment

ARGOCD_CONFIG_REPO_BASE_NAME="kubernetes-lab-argocd-configs" # Base name of the Git repo for Argo CD configurations

HOSTS_FILE="/etc/hosts"
HOSTS_BACKUP_DIR="backup"
HOSTS_START_TAG="### ARGOCD_LAB_START ###"
HOSTS_END_TAG="### ARGOCD_LAB_END ###"

# --- Check for dependencies ---
echo "--- Checking for required tools ---"
if ! command -v yq &> /dev/null; then
    echo "Error: yq (YAML processor) is not installed."
    echo "Please install it: https://github.com/mikefarah/yq#install"
    exit 1
fi
if ! command -v jq &> /dev/null; then
    echo "Error: jq (JSON processor) is not installed."
    echo "Please install it: https://jqlang.github.io/jq/download/"
    exit 1
fi
if ! command -v kubectl &> /dev/null; then
    echo "Error: kubectl is not installed."
    echo "Please install it."
    exit 1
fi

# --- Check for config file ---
if [ ! -f "$CONFIG_FILE" ]; then
    echo "Error: Configuration file '$CONFIG_FILE' not found."
    exit 1
fi

# --- Helper function for sudo tee -a ---
# This function is used to append lines to a file with sudo
append_to_hosts() {
    echo -e "$1" | sudo tee -a "$HOSTS_FILE" > /dev/null
}

# --- Host File Management ---
echo "--- Managing /etc/hosts ---"

# Backup the hosts file
echo "Backing up $HOSTS_FILE to $HOSTS_BACKUP_DIR/"
mkdir -p "$HOSTS_BACKUP_DIR"
cp "$HOSTS_FILE" "$HOSTS_BACKUP_DIR/hosts.$(date +%Y%m%d_%H%M%S)"

# Clean up existing Argo CD lab entries in hosts file
echo "Cleaning up previous Argo CD lab entries from $HOSTS_FILE..."
sudo sed -i "/$HOSTS_START_TAG/,/$HOSTS_END_TAG/d" "$HOSTS_FILE"

# Read Terraform binary path
TERRAFORM_BINARY=$(yq e '.tf-config.binary_path // "terraform"' "$CONFIG_FILE")
echo "Using Terraform binary: $TERRAFORM_BINARY"

echo "--- Generating Terraform variables for Argo CD deployment ---"

# --- MODIFIED YQ COMMAND TO WRAP ALL VALUES IN QUOTES ---
TF_VARS_CONTENT_DEPLOY=$(yq e '
  .argocd-deployment | to_entries | .[] | "\(.key) = \(.value | to_string | to_json)"
  ,
  .kubernetes | to_entries | .[] | "\(.key) = \(.value | to_string | to_json)"
' "$CONFIG_FILE")

# Add comments to the tfvars file
cat > "$TF_MODULE_PATH_DEPLOY/$TFVARS_FILE_DEPLOY" <<EOF
# This file was automatically generated by deploy_argocd.sh for Argo CD deployment
# DO NOT EDIT MANUALLY!

$TF_VARS_CONTENT_DEPLOY
EOF

echo "Generated $TF_MODULE_PATH_DEPLOY/$TFVARS_FILE_DEPLOY:"
cat "$TF_MODULE_PATH_DEPLOY/$TFVARS_FILE_DEPLOY"

# --- Run Terraform Deployment for Argo CD Helm Chart ---
echo "--- Running Terraform in $TF_MODULE_PATH_DEPLOY ---"

pushd "$TF_MODULE_PATH_DEPLOY" > /dev/null

# Initialize Terraform
echo "Running: $TERRAFORM_BINARY init"
if ! $TERRAFORM_BINARY init; then
    echo "Terraform initialization failed."
    popd > /dev/null
    exit 1
fi

# Apply the deployment
echo "Running: $TERRAFORM_BINARY apply -var-file=$TFVARS_FILE_DEPLOY -auto-approve"
if ! $TERRAFORM_BINARY apply -var-file="$TFVARS_FILE_DEPLOY" -auto-approve; then
    echo "Terraform deployment failed."
    popd > /dev/null
    exit 1
fi

popd > /dev/null

echo "--- Argo CD deployment via Terraform completed successfully! ---"

# --- Add Argo CD to /etc/hosts via Ingress ---
echo "--- Adding Argo CD Ingress entry to $HOSTS_FILE ---"

ARGOCD_URL=$(yq e '.argocd-deployment.argocd_url' "$CONFIG_FILE")
ARGOCD_NAMESPACE=$(yq e '.argocd-deployment.argocd_namespace' "$CONFIG_FILE")
ARGOCD_RELEASE_NAME=$(yq e '.argocd-deployment.argocd_release_name' "$CONFIG_FILE")

# The Ingress name is typically the release name for the Argo CD Helm chart followed by '-argocd-server'
ARGOCD_INGRESS_NAME="${ARGOCD_RELEASE_NAME}-server"

echo "Waiting for Argo CD Ingress to get an IP address..."
INGRESS_IP=""
MAX_RETRIES=30
RETRY_DELAY=10 # seconds

for i in $(seq 1 $MAX_RETRIES); do
    # Try both 'ip' and 'hostname' fields for robustness across Ingress controllers
    INGRESS_IP=$(kubectl get ingress "$ARGOCD_INGRESS_NAME" -n "$ARGOCD_NAMESPACE" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null | tr -d '[:space:]' || \
                 kubectl get ingress "$ARGOCD_INGRESS_NAME" -n "$ARGOCD_NAMESPACE" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null | tr -d '[:space:]' || echo "")

    if [ -n "$INGRESS_IP" ]; then
        echo "Ingress IP found: $INGRESS_IP"
        break
    fi
    echo "Attempt $i/$MAX_RETRIES: Ingress IP not yet available. Waiting $RETRY_DELAY seconds..."
    sleep $RETRY_DELAY
done

if [ -z "$INGRESS_IP" ]; then
    echo "Error: Argo CD Ingress did not get an IP address within the timeout."
    echo "Please ensure an Ingress Controller is running in your cluster (e.g., 'minikube addons enable ingress' for Minikube)."
    echo "You might need to manually check 'kubectl get ingress $ARGOCD_INGRESS_NAME -n $ARGOCD_NAMESPACE' for its status."
    exit 1
fi

HOSTS_ENTRY="$INGRESS_IP $ARGOCD_URL"

append_to_hosts "$HOSTS_START_TAG"
append_to_hosts "# Argo CD Dev Lab Entry - automatically added by deploy_argocd.sh"
append_to_hosts "$HOSTS_ENTRY"
append_to_hosts "$HOSTS_END_TAG"

echo "Added '$HOSTS_ENTRY' to $HOSTS_FILE."
echo "Argo CD should now be accessible at https://$ARGOCD_URL"

echo "--- Host File Update Complete! ---"

# --- Configure Argo CD ---
echo "--- Configuring Argo CD ---"

# Get the Git server URL from config.yaml
GIT_SERVER_URL=$(yq e '.gitea-deployment.gitea_url' "$CONFIG_FILE")

# Construct the full Git repository URL
# Assuming the Gitea URL is like 'gitea.mydevlab.local' and the repo is 'kubernetes-lab-argocd-configs'
# The full clone URL might be 'http://gitea.mydevlab.local/git-user/kubernetes-lab-argocd-configs.git'
# For simplicity, if Gitea is on the same URL and allows direct cloning, we'll use:
FULL_ARGOCD_CONFIG_REPO_URL="http://${GIT_SERVER_URL}/git-user/${ARGOCD_CONFIG_REPO_BASE_NAME}.git" # Adjust 'git-user' if it's different

echo "Cloning Argo CD configurations from $FULL_ARGOCD_CONFIG_REPO_URL..."
if [ -d "$ARGOCD_CONFIG_REPO_BASE_NAME" ]; then
    echo "Repository '$ARGOCD_CONFIG_REPO_BASE_NAME' already exists. Pulling latest changes."
    pushd "$ARGOCD_CONFIG_REPO_BASE_NAME" > /dev/null
    git pull
    popd > /dev/null
else
    # Corrected: use the full URL for cloning
    git clone "$FULL_ARGOCD_CONFIG_REPO_URL"
fi

echo "Applying Argo CD configurations..."

# Apply infra-apps.yaml
echo "Applying infra-apps.yaml..."
kubectl apply -f "$ARGOCD_CONFIG_REPO_BASE_NAME/manifests/dev/infra-apps.yaml"
sleep 5

# Apply appprojects
echo "Applying appprojects..."
kubectl apply -f "$ARGOCD_CONFIG_REPO_BASE_NAME/manifests/dev/appprojects/"
sleep 5

# Wait for Argo CD server pods to be ready
echo "Waiting for Argo CD server pods to be ready..."
kubectl -n "$ARGOCD_NAMESPACE" wait pods --selector app.kubernetes.io/instance="$ARGOCD_RELEASE_NAME",app.kubernetes.io/component=server --for condition=Ready --timeout=300s
sleep 5

# Apply remaining manifests
echo "Applying remaining manifests..."
kubectl apply -f "$ARGOCD_CONFIG_REPO_BASE_NAME/manifests/dev/"
sleep 5

# Get admin password
echo "Retrieving Argo CD admin password..."
ARGOCD_ADMIN_PASSWORD=$(kubectl -n "$ARGOCD_NAMESPACE" get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)

echo "argocd, admin , $ARGOCD_ADMIN_PASSWORD" >> passwords.csv
echo "Argo CD admin password is: $ARGOCD_ADMIN_PASSWORD"

echo "--- Argo CD configuration completed successfully! ---"
echo "You can now log in to Argo CD at https://$ARGOCD_URL with username 'admin' and the password above."

echo "--- Full Deployment Workflow Complete! ---"